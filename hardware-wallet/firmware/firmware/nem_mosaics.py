#!/usr/bin/env python
import json, os, sys

import collections, numbers

from google.protobuf import json_format
from itertools import chain

sys.path.insert(0, os.path.join(os.path.dirname(__file__), "protob"))
import types_pb2 as types

try:
    basestring
except NameError:
    basestring = (str, bytes)

HEADER_TEMPLATE = """
// This file is automatically generated by nem_mosaics.py -- DO NOT EDIT!

#ifndef __NEM_MOSAICS_H__
#define __NEM_MOSAICS_H__

#include "types.pb.h"

#define NEM_MOSAIC_DEFINITIONS_COUNT ({count})

extern const NEMMosaicDefinition NEM_MOSAIC_DEFINITIONS[NEM_MOSAIC_DEFINITIONS_COUNT];
extern const NEMMosaicDefinition *NEM_MOSAIC_DEFINITION_XEM;

#endif
""".lstrip()

CODE_TEMPLATE = """
// This file is automatically generated by nem_mosaics.py -- DO NOT EDIT!

#include "nem_mosaics.h"

const NEMMosaicDefinition NEM_MOSAIC_DEFINITIONS[NEM_MOSAIC_DEFINITIONS_COUNT] = {code};

const NEMMosaicDefinition *NEM_MOSAIC_DEFINITION_XEM = NEM_MOSAIC_DEFINITIONS;
""".lstrip()

def format_primitive(value):
    if isinstance(value, bool):
        return ("false", "true")[value]
    elif isinstance(value, numbers.Number):
        return str(value)
    elif isinstance(value, basestring):
        return json.dumps(value)
    elif isinstance(value, collections.Sequence):
        return "{ " + ", ".join(
            format_primitive(item) for item in value
        ) + " }"
    else:
        raise TypeError

def format_struct(struct):
    return "{\n" + "\n".join(
        "\t.{0} = {1},".format(member, value) for member, value in struct.items()
    ) + "\n}"


def format_field(field, value):
    if field.message_type is not None:
        raise TypeError
    elif field.enum_type:
        return "{0}_{1}".format(field.enum_type.name, field.enum_type.values_by_number[value].name)
    elif hasattr(value, "_values"):
        return format_primitive(value._values)
    else:
        return format_primitive(value)

def field_to_meta(field, value):
    if field.label == field.LABEL_REPEATED:
        return ("{}_count".format(field.name), format_primitive(len(value)))
    else:
        return ("has_{}".format(field.name), format_primitive(True))

def message_to_struct(_message, proto):
    message = json_format.ParseDict(_message, proto())
    return collections.OrderedDict(chain.from_iterable(
        (
            field_to_meta(field, value),
            (field.name, format_field(field, value)),
        ) for field, value in message.ListFields()
    ))

def format_message(message, proto):
    return format_struct(message_to_struct(message, proto))

def format_messages(messages, proto):
    return "{" + ",\n".join(
        format_message(message, proto) for message in messages
    ) + "}"

if __name__ == "__main__":
    os.chdir(os.path.abspath(os.path.dirname(__file__)))

    messages = json.load(open("nem_mosaics.json"))

    with open("nem_mosaics.h", "w+") as f:
        f.write(HEADER_TEMPLATE.format(count=format_primitive(len(messages))))

    with open("nem_mosaics.c", "w+") as f:
        f.write(CODE_TEMPLATE.format(code=format_messages(messages, types.NEMMosaicDefinition)))
